"""
Template for creating new modular factors.

To create a new factor:
1. Copy this file and rename it (e.g., scheduling_fatigue.py)
2. Rename the class (e.g., SchedulingFatigueCalculator)
3. Implement the calculate() method with your factor logic
4. Set appropriate weights, thresholds, and impact values
5. The factor will be automatically loaded by the registry!

No need to modify factor_registry.py or any other files.
"""

from typing import Dict, Any, Tuple, Optional, List
import logging
from factors.base_calculator import BaseFactorCalculator, FactorType, FactorConfidence


class TemplateFactorCalculator(BaseFactorCalculator):
    """
    [FACTOR DESCRIPTION HERE]
    
    [EXPLAIN WHAT THIS FACTOR MEASURES AND WHY IT'S CONTRARIAN]
    """
    
    def __init__(self):
        super().__init__()
        
        # REQUIRED: Set the factor weight (portion of category weight)
        self.weight = 0.33  # e.g., 33% of PRIMARY category's 60% = 20% total
        
        # REQUIRED: Set the category (used for legacy compatibility)
        self.category = "custom"  # or "coaching_edge", "situational_context", "momentum_factors"
        
        # REQUIRED: Set description
        self.description = "Brief description of what this factor analyzes"
        
        # REQUIRED: Set output range
        self._min_output = -3.0  # Minimum adjustment this factor can make
        self._max_output = 3.0   # Maximum adjustment this factor can make
        
        # OPTIONAL: Factor type for hierarchical system
        self.factor_type = FactorType.PRIMARY  # or SECONDARY, TRIGGER, MODIFIER
        self.activation_threshold = 1.0  # Minimum absolute value to activate
        self.max_impact = 3.5  # Maximum impact after all adjustments
        
        # OPTIONAL: Configuration parameters specific to this factor
        self.config = {
            'example_param': 0.5,
            'another_param': 10
        }
    
    def calculate(self, home_team: str, away_team: str, context: Optional[Dict[str, Any]] = None) -> float:
        """
        Calculate the factor's adjustment value.
        
        Args:
            home_team: Normalized home team name
            away_team: Normalized away team name
            context: Dictionary containing all available data:
                - home_team_data: Team data for home team
                - away_team_data: Team data for away team
                - coaching_comparison: Coaching data comparison
                - vegas_spread: Current betting spread
                - week: Current week number
                
        Returns:
            Adjustment value between _min_output and _max_output
            Positive values favor home team, negative favor away team
        """
        if not context:
            return 0.0
        
        # Example: Extract data from context
        home_data = context.get('home_team_data', {})
        away_data = context.get('away_team_data', {})
        
        # YOUR FACTOR LOGIC HERE
        # Calculate some contrarian signal
        adjustment = 0.0
        
        # Example calculation
        # home_advantage = self._calculate_something(home_data)
        # away_advantage = self._calculate_something(away_data)
        # adjustment = home_advantage - away_advantage
        
        # REQUIRED: Validate output is within bounds
        return self.validate_output(adjustment)
    
    def calculate_with_confidence(self, home_team: str, away_team: str, 
                                 context: Optional[Dict[str, Any]] = None) -> Tuple[float, FactorConfidence, List[str]]:
        """
        Calculate factor with confidence scoring.
        
        Returns:
            Tuple of (adjustment_value, confidence_level, reasoning_list)
        """
        value = self.calculate(home_team, away_team, context)
        reasoning = []
        
        # Determine confidence based on data quality and signal strength
        if not context:
            return value, FactorConfidence.NONE, ["No data available"]
        
        # Example confidence determination
        if abs(value) > 2.0:
            confidence = FactorConfidence.VERY_HIGH
            reasoning.append("Strong contrarian signal detected")
        elif abs(value) > 1.0:
            confidence = FactorConfidence.HIGH
            reasoning.append("Moderate contrarian signal detected")
        elif abs(value) > 0.5:
            confidence = FactorConfidence.MEDIUM
            reasoning.append("Weak contrarian signal detected")
        else:
            confidence = FactorConfidence.LOW
            reasoning.append("Minimal contrarian signal")
        
        return value, confidence, reasoning
    
    def get_output_range(self) -> Tuple[float, float]:
        """Return the output range for this factor."""
        return (self._min_output, self._max_output)
    
    def get_explanation(self, home_team: str, away_team: str, value: float, 
                       context: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Generate human-readable explanation for the adjustment.
        
        Args:
            home_team: Home team name
            away_team: Away team name
            value: The calculated adjustment value
            context: Game context data
            
        Returns:
            String explanation of what the factor found
        """
        if abs(value) < 0.1:
            return "No significant [factor name] impact detected"
        
        favored_team = home_team if value > 0 else away_team
        impact = "strong" if abs(value) > 2.0 else "moderate" if abs(value) > 1.0 else "slight"
        
        return f"{favored_team} has {impact} [factor type] advantage ({value:+.1f})"
    
    def get_required_data(self) -> Dict[str, bool]:
        """
        Declare what data this factor needs.
        
        The data manager will attempt to fetch required data before
        running this factor. If required data is missing, the factor
        may not run or may run with reduced confidence.
        
        Returns:
            Dictionary of data requirements
        """
        return {
            'team_info': False,        # Basic team information
            'coaching_data': False,    # Coaching comparison data
            'team_stats': False,       # Season statistics
            'schedule_data': False,    # Game schedules and results
            'betting_data': False,     # Historical betting information
            'historical_data': False   # Multi-year historical data
        }


# Optional: Additional helper methods
def _calculate_something(self, team_data: Dict) -> float:
    """Helper method for calculations."""
    # Your logic here
    return 0.0